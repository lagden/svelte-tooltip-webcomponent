import { S as SvelteElement, i as init, a as attribute_to_object, b as insert_dev, s as safe_not_equal, d as dispatch_dev, v as validate_slots, o as onMount, m as onDestroy, e as element, c as space, n as noop, h as add_location, g as attr_dev, j as append_dev, p as listen_dev, l as detach_dev, q as bubble, r as binding_callbacks } from './index-2aba8e47.js';

/* src/components/B.svelte generated by Svelte v3.31.0 */
const file = "src/components/B.svelte";

function create_fragment(ctx) {
	let button;
	let slot;
	let t;
	let div;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			button = element("button");
			slot = element("slot");
			t = space();
			div = element("div");
			this.c = noop;
			add_location(slot, file, 37, 1, 991);
			attr_dev(div, "class", "_btn__ripple");
			add_location(div, file, 38, 1, 1006);
			attr_dev(button, "class", "_btn");
			add_location(button, file, 36, 0, 939);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, button, anchor);
			append_dev(button, slot);
			append_dev(button, t);
			append_dev(button, div);
			/*button_binding*/ ctx[2](button);

			if (!mounted) {
				dispose = listen_dev(button, "click", /*click_handler*/ ctx[1], false, false, false);
				mounted = true;
			}
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(button);
			/*button_binding*/ ctx[2](null);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("b-element", slots, []);
	let element;
	let cssName = "_btn__ripple";

	function rippleAnimation(event) {
		const target = event.currentTarget;
		const circle = document.createElement("div");
		const d = Math.max(target.clientWidth, target.clientHeight);

		const removeCircle = event => {
			circle.removeEventListener("animationend", removeCircle);
			circle.remove();
		};

		circle.addEventListener("animationend", removeCircle);
		circle.style.width = circle.style.height = `${d}px`;
		target.appendChild(circle);
		const rect = target.getBoundingClientRect();
		circle.style.left = `${event.clientX - rect.left - d / 2}px`;
		circle.style.top = `${event.clientY - rect.top - d / 2}px`;
		circle.classList.add(cssName);
	}

	onMount(() => {
		element.addEventListener("click", rippleAnimation);
	});

	onDestroy(() => {
		element.removeEventListener("click", rippleAnimation);
	});

	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<b-element> was created with unknown prop '${key}'`);
	});

	function click_handler(event) {
		bubble($$self, event);
	}

	function button_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			element = $$value;
			$$invalidate(0, element);
		});
	}

	$$self.$capture_state = () => ({
		onMount,
		onDestroy,
		element,
		cssName,
		rippleAnimation
	});

	$$self.$inject_state = $$props => {
		if ("element" in $$props) $$invalidate(0, element = $$props.element);
		if ("cssName" in $$props) cssName = $$props.cssName;
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [element, click_handler, button_binding];
}

class B extends SvelteElement {
	constructor(options) {
		super();

		this.shadowRoot.innerHTML = `<style>._btn{font-size:1em;padding:1em 2em;margin:0;border:0;outline:0;color:white;background-color:blue;border-radius:5px;overflow:hidden;position:relative;cursor:pointer}._btn:disabled{opacity:0.3
}._btn__ripple{border-radius:50%;background-color:white;position:absolute;transform:scale(0);animation:ripple 0.6s linear
}@keyframes ripple{to{transform:scale(2.5);opacity:0
	}}</style>`;

		init(
			this,
			{
				target: this.shadowRoot,
				props: attribute_to_object(this.attributes)
			},
			instance,
			create_fragment,
			safe_not_equal,
			{}
		);

		if (options) {
			if (options.target) {
				insert_dev(options.target, this, options.anchor);
			}
		}
	}
}

customElements.define("b-element", B);

export default B;
//# sourceMappingURL=B.js.map
